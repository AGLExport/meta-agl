From fb66405f4f8ee200a443e22d3b4f56a0e917f785 Mon Sep 17 00:00:00 2001
From: Manuel Bachmann <mbc@iot.bzh>
Date: Wed, 30 Sep 2015 05:22:25 +0200
Subject: [PATCH] Backport to Wayland/Weston 1.9.0 > 1.5.0.

Downgrade requirements to Wayland/Weston 1.9.0 > 1.5.0.

"wl_display_roundtrip_queue()" did not exist at the time,
so just use the wrapper functions instead.

Signed-off-by: Manuel Bachmann <manuel.bachmann@iot.bzh>
---
 .../ilmClient/src/ilm_client_wayland_platform.c    | 15 ++-----
 .../ilmControl/src/ilm_control_wayland_platform.c  | 52 +++++++++++++++++++---
 protocol/CMakeLists.txt                            |  4 +-
 weston-ivi-shell/CMakeLists.txt                    |  4 +-
 4 files changed, 53 insertions(+), 22 deletions(-)

diff --git a/ivi-layermanagement-api/ilmClient/src/ilm_client_wayland_platform.c b/ivi-layermanagement-api/ilmClient/src/ilm_client_wayland_platform.c
index 55b1621..8730616 100644
--- a/ivi-layermanagement-api/ilmClient/src/ilm_client_wayland_platform.c
+++ b/ivi-layermanagement-api/ilmClient/src/ilm_client_wayland_platform.c
@@ -61,7 +61,6 @@ struct ilm_client_context {
     struct wl_registry *registry;
     struct wl_compositor *compositor;
     struct ivi_application *ivi_application;
-    struct wl_event_queue *queue;
 
     struct wl_list list_surface;
 
@@ -167,12 +166,6 @@ destroy_client_resouses(void)
         ctx->ivi_application = NULL;
     }
 
-    if (ctx->queue)
-    {
-        wl_event_queue_destroy(ctx->queue);
-        ctx->queue = NULL;
-    }
-
     if (ctx->registry)
     {
         wl_registry_destroy(ctx->registry);
@@ -203,21 +196,19 @@ init_client(void)
 
     wl_list_init(&ctx->list_surface);
 
-    ctx->queue = wl_display_create_queue(ctx->display);
     ctx->registry = wl_display_get_registry(ctx->display);
     if (ctx->registry == NULL) {
-        wl_event_queue_destroy(ctx->queue);
         fprintf(stderr, "Failed to get registry\n");
         return;
     }
 
-    wl_proxy_set_queue((void*)ctx->registry, ctx->queue);
     if (wl_registry_add_listener(ctx->registry,
                              &registry_client_listener, ctx)) {
         fprintf(stderr, "Failed to add registry listener\n");
         return;
     }
-    wl_display_roundtrip_queue(ctx->display, ctx->queue);
+    wl_display_dispatch(ctx->display);
+    wl_display_roundtrip(ctx->display);
 
     if ((ctx->display == NULL) || (ctx->ivi_application == NULL)) {
         fprintf(stderr, "Failed to connect display at ilm_client\n");
@@ -239,7 +230,7 @@ get_client_instance(void)
         exit(0);
     }
 
-    wl_display_roundtrip_queue(ctx->display, ctx->queue);
+    wl_display_roundtrip(ctx->display);
 
     return ctx;
 }
diff --git a/ivi-layermanagement-api/ilmControl/src/ilm_control_wayland_platform.c b/ivi-layermanagement-api/ilmControl/src/ilm_control_wayland_platform.c
index 8910df5..61bdfc5 100644
--- a/ivi-layermanagement-api/ilmControl/src/ilm_control_wayland_platform.c
+++ b/ivi-layermanagement-api/ilmControl/src/ilm_control_wayland_platform.c
@@ -76,6 +76,46 @@ struct screen_context {
     struct ilm_control_context *ctx;
 };
 
+static void roundtrip_done(void *data, struct wl_callback *callback,
+                           uint32_t serial)
+{
+    (void) serial;
+
+    *(int *)data = 1;
+
+    wl_callback_destroy(callback);
+}
+
+static struct wl_callback_listener roundtrip_listener = {roundtrip_done};
+
+int display_roundtrip_queue(struct wl_display *display,
+                            struct wl_event_queue *queue)
+{
+    int done = 0;
+    int ret = 0;
+    struct wl_callback *callback = wl_display_sync(display);
+
+    if (! callback)
+    {
+        return -1;
+    }
+
+    wl_proxy_set_queue((void *)callback, queue);
+    wl_callback_add_listener(callback, &roundtrip_listener, &done);
+
+    while (ret != -1 && !done)
+    {
+        ret = wl_display_dispatch_queue(display, queue);
+    }
+
+    if (ret == -1 && !done)
+    {
+        wl_callback_destroy(callback);
+    }
+
+    return ret;
+}
+
 static inline void lock_context(struct ilm_control_context *ctx)
 {
    pthread_mutex_lock(&ctx->mutex);
@@ -1304,11 +1344,11 @@ init_control(void)
 
     if (
        // first level objects; ivi_controller
-       wl_display_roundtrip_queue(wl->display, wl->queue) == -1 ||
+       display_roundtrip_queue(wl->display, wl->queue) == -1 ||
        // second level object: ivi_controller_surfaces/layers
-       wl_display_roundtrip_queue(wl->display, wl->queue) == -1 ||
+       display_roundtrip_queue(wl->display, wl->queue) == -1 ||
        // third level objects: ivi_controller_surfaces/layers properties
-       wl_display_roundtrip_queue(wl->display, wl->queue) == -1)
+       display_roundtrip_queue(wl->display, wl->queue) == -1)
     {
         fprintf(stderr, "Failed to initialize wayland connection: %s\n", strerror(errno));
         return -1;
@@ -1349,7 +1389,7 @@ ilmErrorTypes impl_sync_and_acquire_instance(struct ilm_control_context *ctx)
 
     lock_context(ctx);
 
-    if (wl_display_roundtrip_queue(ctx->wl.display, ctx->wl.queue) == -1) {
+    if (display_roundtrip_queue(ctx->wl.display, ctx->wl.queue) == -1) {
         int err = wl_display_get_error(ctx->wl.display);
         fprintf(stderr, "Error communicating with wayland: %s\n", strerror(err));
         unlock_context(ctx);
@@ -2454,7 +2494,7 @@ ilm_getPropertiesOfSurface(t_ilm_uint surfaceID,
             // request statistics for surface
             ivi_controller_surface_send_stats(ctx_surf->controller);
             // force submission
-            int ret = wl_display_roundtrip_queue(ctx->wl.display, ctx->wl.queue);
+            int ret = display_roundtrip_queue(ctx->wl.display, ctx->wl.queue);
 
             // If we got an error here, there is really no sense
             // in returning the properties as something is fundamentally
@@ -2567,7 +2607,7 @@ ilm_commitChanges(void)
     if (ctx->wl.controller != NULL) {
         ivi_controller_commit_changes(ctx->wl.controller);
 
-        if (wl_display_roundtrip_queue(ctx->wl.display, ctx->wl.queue) != -1)
+        if (display_roundtrip_queue(ctx->wl.display, ctx->wl.queue) != -1)
         {
             returnValue = ILM_SUCCESS;
         }
diff --git a/protocol/CMakeLists.txt b/protocol/CMakeLists.txt
index 6842131..207b8f1 100644
--- a/protocol/CMakeLists.txt
+++ b/protocol/CMakeLists.txt
@@ -22,8 +22,8 @@ cmake_minimum_required (VERSION 2.6)
 project(ivi-extension-protocol)
 
 find_package(PkgConfig REQUIRED)
-pkg_check_modules(WAYLAND_CLIENT wayland-client>=1.9.0 REQUIRED)
-pkg_check_modules(WAYLAND_SERVER wayland-server>=1.9.0 REQUIRED)
+pkg_check_modules(WAYLAND_CLIENT wayland-client>=1.5.0 REQUIRED)
+pkg_check_modules(WAYLAND_SERVER wayland-server>=1.5.0 REQUIRED)
 
 find_program(WAYLAND_SCANNER_EXECUTABLE NAMES wayland-scanner)
 
diff --git a/weston-ivi-shell/CMakeLists.txt b/weston-ivi-shell/CMakeLists.txt
index c2664df..927e3f5 100644
--- a/weston-ivi-shell/CMakeLists.txt
+++ b/weston-ivi-shell/CMakeLists.txt
@@ -23,8 +23,8 @@ cmake_minimum_required (VERSION 2.6)
 project(ivi-controller)
 
 find_package(PkgConfig REQUIRED)
-pkg_check_modules(WAYLAND_SERVER wayland-server>=1.9.0 REQUIRED)
-pkg_check_modules(WESTON weston>=1.9.0 REQUIRED)
+pkg_check_modules(WAYLAND_SERVER wayland-server>=1.5.0 REQUIRED)
+pkg_check_modules(WESTON weston>=1.5.0 REQUIRED)
 pkg_check_modules(PIXMAN pixman-1 REQUIRED)
 
 GET_TARGET_PROPERTY(IVI_EXTENSION_INCLUDE_DIRS ivi-extension-protocol INCLUDE_DIRECTORIES)
-- 
1.8.3.1

