From eae2ee2090f8c9c140a1b766bd7312be5f0f308d Mon Sep 17 00:00:00 2001
From: Yuichi Kusakabe <yuichi.kusakabe@jp.fujitsu.com>
Date: Fri, 9 Jun 2017 20:46:54 +0900
Subject: [PATCH 3/3] Add hibernation image area

0x40000000 <-> 0x77FFFFFF : kernel
0x78000000 <-> 0x7FFFFFFF : hibernation image area

Signed-off-by: Yuichi Kusakabe <yuichi.kusakabe@jp.fujitsu.com>
---
 common/cmd_swsuspmem.c | 20 +++++++++++++-------
 1 file changed, 13 insertions(+), 7 deletions(-)

diff --git a/common/cmd_swsuspmem.c b/common/cmd_swsuspmem.c
index 6980aaf..dbc000c 100644
--- a/common/cmd_swsuspmem.c
+++ b/common/cmd_swsuspmem.c
@@ -116,8 +116,9 @@ struct swsusp_finish_context {
 #define USED_ADDRESS_TOP	(CONFIG_SYS_SDRAM_BASE)
 #define USED_ADDRESS_END	(CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_LOAD_OFFSET)
 #else
-#define USED_ADDRESS_TOP	(0x40000000)
-#define USED_ADDRESS_END	(0x48000000)
+#define CONFIG_SYS_LOAD_OFFSET	0x0
+#define USED_ADDRESS_TOP	(CONFIG_SYS_SDRAM_BASE)
+#define USED_ADDRESS_END	(CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_LOAD_OFFSET)
 #endif
 #define PG_UB2ZERO(pg) ((pg) - CONFIG_SYS_SDRAM_BASE / PAGE_SIZE)
 static u32 const exclude_min_page =
@@ -157,7 +158,7 @@ static struct swsuspmem_hook *_hook;
 	} while (0)
 
 #ifdef PAGEMAP_DEBUG
-static int debugout;
+static int debugout = 1;
 static int _last_read_pages;
 #define PAGEMAP_INFO(_msg, ...)				\
 	do {						\
@@ -231,7 +232,7 @@ static inline u32 addr2pg(void *addr)
 {
 	return ((u32)(addr)) / PAGE_SIZE;
 }
-static void *offt_addr = (void *)0x44000000;
+static void *offt_addr = (void *)0x78000000;
 static int page_read_mem(u64 page, void *addr)
 {
 	memcpy(addr, (u8 *)offt_addr + page * PAGE_SIZE, PAGE_SIZE);
@@ -577,7 +578,7 @@ int do_checksnapimage(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	if (memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)
 			|| (swsusp_header->img_size == 0)
-			|| (swsusp_header->img_size > 0x03fff000)) {
+			|| (swsusp_header->img_size > 0x05fff000)) {
 		printf("No hibernation image present\n");
 		CALL_HOOK(err_hook, SWSUSPMEM_BROKENIMAGE);
 		return 0;
@@ -674,7 +675,9 @@ int do_swsuspmem(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	/* Allow for 16 pages of stack */
 	max_page = gd->start_addr_sp / PAGE_SIZE - 32;
 	high_page = (((gd->relocaddr + _bss_end_ofs)
-				+ (PAGE_SIZE - 1)) / PAGE_SIZE) + 1;
+				+ (PAGE_SIZE - 1)) / PAGE_SIZE) + 1 + 0xf;
+	if (high_page > 0x7ffff)
+		high_page = 0x7ffff;
 #define pfn_is_occupied(pfn) (page > max_page && page <= high_page)
 #ifdef PAGEMAP_DEBUG
 	PAGEMAP_INFO(" *gd->start_addr_sp:%p\n",
@@ -711,7 +714,7 @@ int do_swsuspmem(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 
 	if (memcmp(HIBERNATE_SIG, swsusp_header->sig, 10)
 			|| (swsusp_header->img_size == 0)
-			|| (swsusp_header->img_size > 0x03fff000)) {
+			|| (swsusp_header->img_size > 0x05fff000)) {
 		printf("No hibernation image present\n");
 		CALL_HOOK(err_hook, SWSUSPMEM_BROKENIMAGE);
 		return 0;
@@ -830,8 +833,11 @@ int do_swsuspmem(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 			continue;
 		} else if (unlikely(pfn_is_low(page) &&
 					pfn_is_occupied(page))) {
+			/* Virtual 32-bit original address */
 			remap_orig[remap_idx] = pg2addr(page);
+			/* allocating new free page */
 			page = free_page_get_next();
+			/* Virtual 32-bit remap address */
 			remap_temp[remap_idx] = pg2addr(page);
 			remap_idx++;
 #ifdef PAGEMAP_DEBUG
-- 
1.8.3.1

